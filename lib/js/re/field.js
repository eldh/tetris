// Generated by BUCKLESCRIPT VERSION 4.0.5, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var $$Array = require("bs-platform/lib/js/array.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Level = require("./level.js");
var Piece = require("./piece.js");
var Pixel = require("./pixel.js");
var Score = require("./score.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");
var ReasonReact = require("reason-react/lib/js/src/ReasonReact.js");
var Js_primitive = require("bs-platform/lib/js/js_primitive.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var FieldTouchHandler = require("./fieldTouchHandler.js");
var Text$BsReactNative = require("bs-react-native/lib/js/src/components/text.js");
var View$BsReactNative = require("bs-react-native/lib/js/src/components/view.js");
var Style$BsReactNative = require("bs-react-native/lib/js/src/style.js");
var Dimensions$BsReactNative = require("bs-react-native/lib/js/src/dimensions.js");
var SafeAreaView$BsReactNative = require("bs-react-native/lib/js/src/components/safeAreaView.js");

var ImpossibleLines = Caml_exceptions.create("Field.ImpossibleLines");

var windowWidth = Dimensions$BsReactNative.get(/* window */-762539024).width;

function getMoveScore(level, lines) {
  var multiplier;
  if (lines > 4 || lines < 0) {
    throw ImpossibleLines;
  } else {
    switch (lines) {
      case 0 : 
          multiplier = 0;
          break;
      case 1 : 
          multiplier = 40;
          break;
      case 2 : 
          multiplier = 100;
          break;
      case 3 : 
          multiplier = 300;
          break;
      case 4 : 
          multiplier = 1200;
          break;
      
    }
  }
  return Caml_int32.imul(multiplier, level + 1 | 0);
}

function coordinatesForPiece(param) {
  var x = param[/* x */2];
  var y = param[/* y */1];
  var rotatedPosition = List.nth(Piece.getPositionsForPeice(param[/* piece */0]), param[/* rotation */3]);
  return List.map((function (param) {
                return /* tuple */[
                        param[0] + x | 0,
                        param[1] + y | 0
                      ];
              }), rotatedPosition);
}

function hasHitGround(positions) {
  return List.fold_left((function (min, param) {
                var y = param[1];
                var match = y < min;
                if (match) {
                  return y;
                } else {
                  return min;
                }
              }), 100, positions) < 0;
}

function hasHitSide(positions) {
  var hasHitLeftSide = List.fold_left((function (min, param) {
          var x = param[0];
          var match = x < min;
          if (match) {
            return x;
          } else {
            return min;
          }
        }), 999, positions) < 0;
  var hasHitRightSide = List.fold_left((function (max, param) {
          var x = param[0];
          var match = x > max;
          if (match) {
            return x;
          } else {
            return max;
          }
        }), -999, positions) >= 10;
  if (hasHitLeftSide) {
    return true;
  } else {
    return hasHitRightSide;
  }
}

function pieceToPixels(piece) {
  return List.map((function (param) {
                return /* record */[
                        /* x */param[0],
                        /* y */param[1],
                        /* piece */piece[/* piece */0]
                      ];
              }), coordinatesForPiece(piece));
}

function filledCoords(filled) {
  return List.flatten(List.mapi((function (i, row) {
                    return List.map((function (param) {
                                  return /* tuple */[
                                          param[/* x */0],
                                          i
                                        ];
                                }), row);
                  }), filled));
}

function isDead(piece, filled) {
  return List.exists((function (param) {
                return param[1] > 20;
              }), List.append(coordinatesForPiece(piece), filledCoords(filled)));
}

function collidesWithExisting(filled, coords) {
  return List.exists((function (coord) {
                return List.exists((function (fromPiece) {
                              return Caml_obj.caml_equal(coord, fromPiece);
                            }), coords);
              }), filled);
}

function positionedPiece(piece) {
  return /* record */[
          /* piece */piece,
          /* y */22,
          /* x */4,
          /* rotation */0
        ];
}

function validMove(filled, potentialPiece) {
  var coords = coordinatesForPiece(potentialPiece);
  return !(hasHitGround(coords) || hasHitSide(coords) || collidesWithExisting(filledCoords(filled), coords));
}

function canMoveY(param) {
  var activePiece = param[/* activePiece */1];
  return validMove(param[/* filled */3], /* record */[
              /* piece */activePiece[/* piece */0],
              /* y */activePiece[/* y */1] - 1 | 0,
              /* x */activePiece[/* x */2],
              /* rotation */activePiece[/* rotation */3]
            ]);
}

function canMoveX(direction, param) {
  var activePiece = param[/* activePiece */1];
  var match = direction === /* Left */0;
  return validMove(param[/* filled */3], /* record */[
              /* piece */activePiece[/* piece */0],
              /* y */activePiece[/* y */1],
              /* x */activePiece[/* x */2] + (
                match ? -1 : 1
              ) | 0,
              /* rotation */activePiece[/* rotation */3]
            ]);
}

function canRotate(param) {
  var activePiece = param[/* activePiece */1];
  var match = activePiece[/* rotation */3] === 3;
  return validMove(param[/* filled */3], /* record */[
              /* piece */activePiece[/* piece */0],
              /* y */activePiece[/* y */1],
              /* x */activePiece[/* x */2],
              /* rotation */match ? 0 : activePiece[/* rotation */3] + 1 | 0
            ]);
}

function newForRow(index, coords) {
  return List.filter((function (param) {
                  return param[/* y */1] === index;
                }))(coords);
}

function pixelToFilled(param) {
  return /* record */[
          /* x */param[/* x */0],
          /* piece */param[/* piece */2]
        ];
}

function addActiveToFilled(param) {
  var newCoords = pieceToPixels(param[/* activePiece */1]);
  return List.filter((function (row) {
                  return List.length(row) !== 10;
                }))(List.mapi((function (i, row) {
                    return List.append(List.map(pixelToFilled, newForRow(i, newCoords)), row);
                  }), param[/* filled */3]));
}

var component = ReasonReact.reducerComponent("Field");

function make() {
  return /* record */[
          /* debugName */component[/* debugName */0],
          /* reactClassInternal */component[/* reactClassInternal */1],
          /* handedOffState */component[/* handedOffState */2],
          /* willReceiveProps */component[/* willReceiveProps */3],
          /* didMount */(function (self) {
              var intervalId = setInterval((function () {
                      return Curry._1(self[/* send */3], /* Tick */0);
                    }), 500);
              return Curry._1(self[/* onUnmount */4], (function () {
                            clearInterval(intervalId);
                            return /* () */0;
                          }));
            }),
          /* didUpdate */component[/* didUpdate */5],
          /* willUnmount */component[/* willUnmount */6],
          /* willUpdate */component[/* willUpdate */7],
          /* shouldUpdate */component[/* shouldUpdate */8],
          /* render */(function (param) {
              var send = param[/* send */3];
              var match = param[/* state */1];
              var activePiece = match[/* activePiece */1];
              var boardAspectRatio = 2;
              return ReasonReact.element(undefined, undefined, Curry.app(SafeAreaView$BsReactNative.make, [
                              undefined,
                              undefined,
                              undefined,
                              undefined,
                              undefined,
                              undefined,
                              undefined,
                              undefined,
                              undefined,
                              Js_primitive.some(Style$BsReactNative.style(/* :: */[
                                        Style$BsReactNative.position(/* Relative */1),
                                        /* :: */[
                                          Style$BsReactNative.display(/* Flex */0),
                                          /* :: */[
                                            Style$BsReactNative.backgroundColor(/* String */Block.__(0, ["rgb(40, 40, 40)"])),
                                            /* :: */[
                                              Style$BsReactNative.flex(1),
                                              /* :: */[
                                                Style$BsReactNative.aspectRatio(1 / boardAspectRatio),
                                                /* [] */0
                                              ]
                                            ]
                                          ]
                                        ]
                                      ])),
                              undefined,
                              undefined,
                              undefined,
                              undefined,
                              undefined,
                              undefined,
                              undefined,
                              undefined,
                              undefined,
                              undefined,
                              /* array */[
                                match[/* gameOver */0] ? ReasonReact.element(undefined, undefined, View$BsReactNative.make(undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, Js_primitive.some(Style$BsReactNative.style(/* :: */[
                                                      Style$BsReactNative.position(/* Relative */1),
                                                      /* :: */[
                                                        Style$BsReactNative.display(/* Flex */0),
                                                        /* :: */[
                                                          Style$BsReactNative.flex(1),
                                                          /* [] */0
                                                        ]
                                                      ]
                                                    ])), undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined)(/* array */[ReasonReact.element(undefined, undefined, Text$BsReactNative.make(undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, /* array */["Game over"]))])) : ReasonReact.element(undefined, undefined, FieldTouchHandler.make((function (dir) {
                                              return Curry._1(send, /* MoveX */[dir]);
                                            }), (function () {
                                              return Curry._1(send, /* Rotate */3);
                                            }), (function () {
                                              return Curry._1(send, /* MoveY */1);
                                            }), /* array */[
                                            ReasonReact.element("piece" + (String(activePiece[/* x */2]) + String(activePiece[/* y */1])), undefined, Piece.make(activePiece[/* piece */0], activePiece[/* rotation */3], /* tuple */[
                                                      activePiece[/* x */2],
                                                      activePiece[/* y */1]
                                                    ], /* array */[])),
                                            $$Array.of_list(List.flatten(List.mapi((function (i, row) {
                                                            return List.map((function (pixel) {
                                                                          return ReasonReact.element("pixel" + (String(pixel[/* x */0]) + String(i)), undefined, Pixel.make(/* tuple */[
                                                                                          pixel[/* x */0],
                                                                                          i
                                                                                        ], "rgb(90,90,90)", /* array */[]));
                                                                        }), row);
                                                          }), match[/* filled */3])))
                                          ])),
                                ReasonReact.element(undefined, undefined, Score.make(match[/* score */4], /* array */[])),
                                ReasonReact.element(undefined, undefined, Level.make(match[/* level */5], /* array */[]))
                              ]
                            ]));
            }),
          /* initialState */(function () {
              return /* record */[
                      /* gameOver */false,
                      /* activePiece */positionedPiece(Piece.createPiece(/* () */0)),
                      /* nextPiece */Piece.createPiece(/* () */0),
                      /* filled */$$Array.to_list(Caml_array.caml_make_vect(20, /* [] */0)),
                      /* score */0,
                      /* level */0
                    ];
            }),
          /* retainedProps */component[/* retainedProps */11],
          /* reducer */(function (action, state) {
              if (typeof action === "number") {
                switch (action) {
                  case 0 : 
                      var match = state[/* gameOver */0];
                      if (match) {
                        return /* NoUpdate */0;
                      } else {
                        return /* SideEffects */Block.__(1, [(function (self) {
                                      var match = canMoveY(self[/* state */1]);
                                      return Curry._1(self[/* send */3], match ? /* MoveY */1 : /* NewPiece */2);
                                    })]);
                      }
                  case 1 : 
                      var match$1 = canMoveY(state);
                      if (match$1) {
                        var init = state[/* activePiece */1];
                        return /* Update */Block.__(0, [/* record */[
                                    /* gameOver */state[/* gameOver */0],
                                    /* activePiece : record */[
                                      /* piece */init[/* piece */0],
                                      /* y */state[/* activePiece */1][/* y */1] - 1 | 0,
                                      /* x */init[/* x */2],
                                      /* rotation */init[/* rotation */3]
                                    ],
                                    /* nextPiece */state[/* nextPiece */2],
                                    /* filled */state[/* filled */3],
                                    /* score */state[/* score */4],
                                    /* level */state[/* level */5]
                                  ]]);
                      } else {
                        return /* NoUpdate */0;
                      }
                  case 2 : 
                      var filled = addActiveToFilled(state);
                      var match$2 = isDead(state[/* activePiece */1], state[/* filled */3]);
                      return /* Update */Block.__(0, [match$2 ? /* record */[
                                    /* gameOver */true,
                                    /* activePiece */state[/* activePiece */1],
                                    /* nextPiece */state[/* nextPiece */2],
                                    /* filled */state[/* filled */3],
                                    /* score */state[/* score */4],
                                    /* level */state[/* level */5]
                                  ] : /* record */[
                                    /* gameOver */state[/* gameOver */0],
                                    /* activePiece */positionedPiece(state[/* nextPiece */2]),
                                    /* nextPiece */Piece.createPiece(/* () */0),
                                    /* filled */filled,
                                    /* score */state[/* score */4] + getMoveScore(state[/* level */5], 1) | 0,
                                    /* level */state[/* level */5]
                                  ]]);
                  case 3 : 
                      var match$3 = canRotate(state);
                      if (match$3) {
                        var init$1 = state[/* activePiece */1];
                        var match$4 = state[/* activePiece */1][/* rotation */3] === 3;
                        return /* Update */Block.__(0, [/* record */[
                                    /* gameOver */state[/* gameOver */0],
                                    /* activePiece : record */[
                                      /* piece */init$1[/* piece */0],
                                      /* y */init$1[/* y */1],
                                      /* x */init$1[/* x */2],
                                      /* rotation */match$4 ? 0 : state[/* activePiece */1][/* rotation */3] + 1 | 0
                                    ],
                                    /* nextPiece */state[/* nextPiece */2],
                                    /* filled */state[/* filled */3],
                                    /* score */state[/* score */4],
                                    /* level */state[/* level */5]
                                  ]]);
                      } else {
                        return /* NoUpdate */0;
                      }
                  
                }
              } else {
                var dir = action[0];
                var match$5 = canMoveX(dir, state);
                if (match$5) {
                  var init$2 = state[/* activePiece */1];
                  return /* Update */Block.__(0, [/* record */[
                              /* gameOver */state[/* gameOver */0],
                              /* activePiece : record */[
                                /* piece */init$2[/* piece */0],
                                /* y */init$2[/* y */1],
                                /* x */state[/* activePiece */1][/* x */2] + (
                                  dir ? 1 : -1
                                ) | 0,
                                /* rotation */init$2[/* rotation */3]
                              ],
                              /* nextPiece */state[/* nextPiece */2],
                              /* filled */state[/* filled */3],
                              /* score */state[/* score */4],
                              /* level */state[/* level */5]
                            ]]);
                } else {
                  return /* NoUpdate */0;
                }
              }
            }),
          /* jsElementWrapped */component[/* jsElementWrapped */13]
        ];
}

var boardHeight = 20;

var boardWidth = 10;

exports.ImpossibleLines = ImpossibleLines;
exports.boardHeight = boardHeight;
exports.boardWidth = boardWidth;
exports.windowWidth = windowWidth;
exports.getMoveScore = getMoveScore;
exports.coordinatesForPiece = coordinatesForPiece;
exports.hasHitGround = hasHitGround;
exports.hasHitSide = hasHitSide;
exports.pieceToPixels = pieceToPixels;
exports.filledCoords = filledCoords;
exports.isDead = isDead;
exports.collidesWithExisting = collidesWithExisting;
exports.positionedPiece = positionedPiece;
exports.validMove = validMove;
exports.canMoveY = canMoveY;
exports.canMoveX = canMoveX;
exports.canRotate = canRotate;
exports.newForRow = newForRow;
exports.pixelToFilled = pixelToFilled;
exports.addActiveToFilled = addActiveToFilled;
exports.component = component;
exports.make = make;
/* windowWidth Not a pure module */
